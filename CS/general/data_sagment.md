# data segment

참고: https://en.wikipedia.org/wiki/Data_segment

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/50/Program_memory_layout.pdf/page1-299px-Program_memory_layout.pdf.jpg" alt="img"  style="zoom:60%;" />

### 개요

프로그램이 올라가는 메모리는 코드, 데이터(BSS), 힙, 스택 영역으로 구분된다.

크게는 코드 세그먼트(코드 영역), 데이터 세그먼트(나머지)로 구분 된다.

코드, 데이터, bss, 스택은 컴파일 타임에 크기 결정됨



### 빌드 과정

* 빌드의 정의
  * 코드 파일을 실행 가능한 독립 소프트웨어 형태로 가공하는 과정
  * 컴파일, 링크

* 컴파일

  * 코드 -> 기계어
  * 오브젝트 파일

* 링킹

  * 여러 오브젝트 파일들, 공용 라이브러리 -> 실행 파일(exe 파일)

  

* 로드

  * 메모리 적재 및 수행
  * 로딩 과정
    * 코드(바이너리)를 코드 영역으로 보냄
    * 데이터 영역 로드타임 변수 메모리 할당
    * 로드타임 변수 초기화
  * 이후 main 함수 호출



### 코드(텍스트) 영역

* 프로그램이 메모리에 올라갈 때 크기가 결정됨. 프로그램 실행부터 끝날 때까지 메모리를 차지함.
* read-only로 지정됨, 즉 저장되는 데이터들은 불변
* 컴파일된 기계어가 저장됨
* 명령어(함수, 제어문) 등이 저장됨.
* 상수와 리터럴들이 저장됨

* * a =7, final n = 8에서 a는 변수, 7, 8은 리터럴, n은 상수
    * 상수는 변하지 않는 변수
  * 파이썬의 경우, 모든 변수는 특정 객체에 대한 참조임. 따라서 상수 변수의 개념이 없음.
  
  

### 데이터 영역, BSS 영역

* 프로그램이 메모리에 올라갈 때 메모리 크기가 결정됨. 프로그램 실행부터 끝날 때까지 메모리를 차지함.
* 프로그램이 로딩될 때(main 함수 호출 전) 할당됨. 그래서 전역, 정적 변수는 로드타임 변수라고도 불림.
* 전역 변수는 항상 유지되야 하므로, 프로그램 시작과 동시에 할당됨.
  * static 변수는 프로그램이 실행됐을 때 공간만 할당되고 함수가 실행될 때 값이 채워짐. 단, global로 선언된 static은 예외
* 중간에 예컨대 전역 변수 등이 바뀔 수 있으므로 read-write로 지정됨.
* 초기화가 안 된 데이터는 BSS에 0으로 저장됨. 초기화된 데이터는 데이터 영역에 저장됨. (전역 변수, 정적 변수, 배열 등)
* 초기화 되지 않은 데이터까지 컴파일 타임에 결정하면, 어떤 크기의 값이 들어갈 지 모르므로, 큰 메모리를 줘야 할테고, 이는 낭비로 이어지기에 bss 영역으로 작게 만들어 두는거
* 데이터 영역, bss영역은 파일 크기를 직접적으로 증가시키기 때문에, 이런 식으로 비용을 줄이려고 하는 것



### 스택 영역

* 모든 활성 함수의 **활성 레코드** 가 저장됨. 활성 레코드는 현재 호출 중인 함수를 의미하는데, 함수의 리턴 값, 파라미터, 지역 변수, 주소 등의 정보를 포함함 
* main부터 시작, 함수들이 실행되고 소멸될 때마다 할당되며 반환 됨. 스택의 크기도 계속 변함.
* 스택 영역이 너무 커지면 힙 공간이 부족해지기 때문에 크기가 제한됨. 이를 넘어설 때 스택 오버플로우 에러 발생



### 힙 영역

* 힙은 동적으로, 런 타임에 전체 메모리 크기가 결정됨(이전까지는 컴파일 타임).

  * 기본적으로 스택보다 많은 허용 범위를 가짐. 허용된 범위를 넘어설 경우 힙 오버플로우 에러 발생

* 동적 할당의 필요성

  * 예컨대, 사용자로부터 필요한 값을 받아야 하는 경우,

    ```python
    int i;
    std::cin>>i;
    int arr[i];
    ```

    위 코드는 제대로 돌아가지 않음. 입력 값을 런 타임에 받으므로 컴파일 타임에 이를 고려해서 크기를 지정해줄 수가 없음. 사용자에게 필요하다고 예상되는 크기보다 큰 크기를 주면 보통 문제가 없겠지만 메모리를 경제적으로 써야할 때 동적할당이 유용.

    ```python
    int i; 
    std::cin >> i; 
    int *arr = new int[i]; 
    delete[] arr;
    ```

    

* 할당된 메모리는 프로그래머가 해제하거나(delete) 가비지 컬렉팅 되기 전까지 유지된다. 프로세스 실행 중 해당 메모리가 할당된 채로 유지되어 낭비가 발생하므로 메모리 사용이 끝났으면 해제를 해줘야 함. 해제 해줘야할 메모리를 냅둬서 생기는 문제를 **메모리 누수**라 부름

* 보통 GC가 이런 문제를 처리해줌





### 예시

`static int x = strlen("test";)`

위 코드는 컴파일 오류가 나옴. 로드 타임 변수를 함수 반환 값으로 초기화하려고 했기 때문. 함수는 런 타임때 실행될텐데.



`static int x;` ` x= strlen("test";)` 

위 코드는 정상적으로 작동함. 로드 타임에 x를 0으로 초기화 시키고. 런타임에 함수를 호출해 값을 넣음.





